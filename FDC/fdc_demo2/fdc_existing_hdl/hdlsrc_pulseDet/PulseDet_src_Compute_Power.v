// Copyright 2025 The MathWorks, Inc.
// -------------------------------------------------------------
// 
// File Name: custom_hdl_prj\hdlsrc\pulse_detector_ipcore\PulseDet_src_Compute_Power.v
// Created: 2023-08-26 18:01:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PulseDet_src_Compute_Power
// Source Path: pulse_detector_ipcore/Pulse Detector IP/Pulse Detector/Compute Power
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PulseDet_src_Compute_Power
          (clk,
           reset,
           enb,
           data_in_re,
           data_in_im,
           filter_in_re,
           filter_in_im,
           valid_in,
           data_out_re,
           data_out_im,
           pow_out,
           valid_out);


  input   clk;
  input   reset;
  input   enb;
  input   signed [15:0] data_in_re;  // sfix16_En14
  input   signed [15:0] data_in_im;  // sfix16_En14
  input   signed [39:0] filter_in_re;  // sfix40_En37
  input   signed [39:0] filter_in_im;  // sfix40_En37
  input   valid_in;
  output  signed [15:0] data_out_re;  // sfix16_En14
  output  signed [15:0] data_out_im;  // sfix16_En14
  output  signed [17:0] pow_out;  // sfix18_En11
  output  valid_out;


  reg signed [15:0] Delay16_out1_re;  // sfix16_En14
  reg signed [15:0] Delay16_out1_im;  // sfix16_En14
  reg signed [15:0] Delay1_out1_re;  // sfix16_En14
  reg signed [15:0] Delay1_out1_im;  // sfix16_En14
  reg signed [15:0] Delay14_out1_re;  // sfix16_En14
  reg signed [15:0] Delay14_out1_im;  // sfix16_En14
  reg signed [15:0] Delay15_out1_re;  // sfix16_En14
  reg signed [15:0] Delay15_out1_im;  // sfix16_En14
  wire signed [17:0] Data_Type_Conversion1_out1_re;  // sfix18_En15
  wire signed [17:0] Data_Type_Conversion1_out1_im;  // sfix18_En15
  reg signed [17:0] Delay10_out1_re;  // sfix18_En15
  reg signed [17:0] Delay10_out1_im;  // sfix18_En15
  reg signed [17:0] Delay6_out1;  // sfix18_En15
  reg signed [17:0] Delay3_out1;  // sfix18_En15
  wire signed [35:0] Product_out1;  // sfix36_En30
  reg signed [35:0] Delay7_out1;  // sfix36_En30
  reg signed [17:0] Delay2_out1;  // sfix18_En15
  reg signed [17:0] Delay13_out1;  // sfix18_En15
  wire signed [35:0] Product1_out1;  // sfix36_En30
  reg signed [35:0] Delay8_out1;  // sfix36_En30
  wire signed [36:0] Add_add_cast;  // sfix37_En30
  wire signed [36:0] Add_add_cast_1;  // sfix37_En30
  wire signed [36:0] Add_out1;  // sfix37_En30
  reg signed [36:0] Delay9_out1;  // sfix37_En30
  wire signed [17:0] Data_Type_Conversion_out1;  // sfix18_En11
  reg  Delay4_out1;
  reg  Delay5_out1;
  reg  Delay11_out1;
  reg  Delay12_out1;


  always @(posedge clk)
    begin : Delay16_process
      if (reset == 1'b1) begin
        Delay16_out1_re <= 16'sb0000000000000000;
        Delay16_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay16_out1_re <= data_in_re;
          Delay16_out1_im <= data_in_im;
        end
      end
    end



  always @(posedge clk)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1_re <= 16'sb0000000000000000;
        Delay1_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay1_out1_re <= Delay16_out1_re;
          Delay1_out1_im <= Delay16_out1_im;
        end
      end
    end



  always @(posedge clk)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_out1_re <= 16'sb0000000000000000;
        Delay14_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay14_out1_re <= Delay1_out1_re;
          Delay14_out1_im <= Delay1_out1_im;
        end
      end
    end



  always @(posedge clk)
    begin : Delay15_process
      if (reset == 1'b1) begin
        Delay15_out1_re <= 16'sb0000000000000000;
        Delay15_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay15_out1_re <= Delay14_out1_re;
          Delay15_out1_im <= Delay14_out1_im;
        end
      end
    end



  assign data_out_re = Delay15_out1_re;

  assign data_out_im = Delay15_out1_im;

  assign Data_Type_Conversion1_out1_re = filter_in_re[39:22];
  assign Data_Type_Conversion1_out1_im = filter_in_im[39:22];



  always @(posedge clk)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1_re <= 18'sb000000000000000000;
        Delay10_out1_im <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay10_out1_re <= Data_Type_Conversion1_out1_re;
          Delay10_out1_im <= Data_Type_Conversion1_out1_im;
        end
      end
    end



  always @(posedge clk)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay6_out1 <= Delay10_out1_re;
        end
      end
    end



  always @(posedge clk)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1 <= Delay10_out1_re;
        end
      end
    end



  assign Product_out1 = Delay6_out1 * Delay3_out1;



  always @(posedge clk)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Delay7_out1 <= Product_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1 <= Delay10_out1_im;
        end
      end
    end



  always @(posedge clk)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb) begin
          Delay13_out1 <= Delay10_out1_im;
        end
      end
    end



  assign Product1_out1 = Delay2_out1 * Delay13_out1;



  always @(posedge clk)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Delay8_out1 <= Product1_out1;
        end
      end
    end



  assign Add_add_cast = {Delay7_out1[35], Delay7_out1};
  assign Add_add_cast_1 = {Delay8_out1[35], Delay8_out1};
  assign Add_out1 = Add_add_cast + Add_add_cast_1;



  always @(posedge clk)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_out1 <= 37'sh0000000000;
      end
      else begin
        if (enb) begin
          Delay9_out1 <= Add_out1;
        end
      end
    end



  assign Data_Type_Conversion_out1 = Delay9_out1[36:19];



  assign pow_out = Data_Type_Conversion_out1;

  always @(posedge clk)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay4_out1 <= valid_in;
        end
      end
    end



  always @(posedge clk)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay5_out1 <= Delay4_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay11_out1 <= Delay5_out1;
        end
      end
    end



  always @(posedge clk)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay12_out1 <= Delay11_out1;
        end
      end
    end



  assign valid_out = Delay12_out1;

endmodule  // PulseDet_src_Compute_Power

