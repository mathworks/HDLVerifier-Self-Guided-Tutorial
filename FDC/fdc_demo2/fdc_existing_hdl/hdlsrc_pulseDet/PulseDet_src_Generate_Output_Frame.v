// Copyright 2025 The MathWorks, Inc.
// -------------------------------------------------------------
// 
// File Name: custom_hdl_prj\hdlsrc\pulse_detector_ipcore\PulseDet_src_Generate_Output_Frame.v
// Created: 2023-08-26 18:01:37
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PulseDet_src_Generate_Output_Frame
// Source Path: pulse_detector_ipcore/Pulse Detector IP/Generate Output Frame
// Hierarchy Level: 1
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PulseDet_src_Generate_Output_Frame
          (clk,
           reset,
           enb,
           data_in_re,
           data_in_im,
           valid_in,
           detected,
           length,
           ready_in,
           data_out_re,
           data_out_im,
           valid_out);


  input   clk;
  input   reset;
  input   enb;
  input   signed [15:0] data_in_re;  // sfix16_En14
  input   signed [15:0] data_in_im;  // sfix16_En14
  input   valid_in;
  input   detected;
  input   [31:0] length;  // uint32
  input   ready_in;
  output  signed [15:0] data_out_re;  // sfix16_En14
  output  signed [15:0] data_out_im;  // sfix16_En14
  output  valid_out;


  reg signed [15:0] Delay_out1_re;  // sfix16_En14
  reg signed [15:0] Delay_out1_im;  // sfix16_En14
  wire [31:0] count_step;  // uint32
  reg [31:0] HDL_Counter_out1;  // uint32
  wire [31:0] count;  // uint32
  wire AND_out1;
  wire [31:0] count_1;  // uint32
  wire Compare_To_Zero_out1;
  wire NOT_out1;
  wire AND2_out1;
  wire [31:0] count_2;  // uint32


  always @(posedge clk)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1_re <= 16'sb0000000000000000;
        Delay_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1_re <= data_in_re;
          Delay_out1_im <= data_in_im;
        end
      end
    end



  assign data_out_re = Delay_out1_re;

  assign data_out_im = Delay_out1_im;

  // Free running, Unsigned Counter
  //  initial value   = 0
  //  step value      = -1
  assign count_step = 32'b00000000000000000000000000000001;



  assign count = HDL_Counter_out1 - count_step;



  assign count_1 = (AND_out1 == 1'b0 ? HDL_Counter_out1 :
              count);



  assign NOT_out1 =  ~ Compare_To_Zero_out1;



  assign AND2_out1 = NOT_out1 & detected;



  assign count_2 = (AND2_out1 == 1'b0 ? count_1 :
              length);



  always @(posedge clk)
    begin : HDL_Counter_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1 <= count_2;
        end
      end
    end



  assign Compare_To_Zero_out1 = HDL_Counter_out1 > 32'b00000000000000000000000000000000;



  assign AND_out1 = Compare_To_Zero_out1 & (valid_in & ready_in);



  assign valid_out = AND_out1;

endmodule  // PulseDet_src_Generate_Output_Frame

