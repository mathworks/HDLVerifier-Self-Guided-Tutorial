// Copyright 2025 The MathWorks, Inc.
// -------------------------------------------------------------
// 
// File Name: custom_hdl_prj\hdlsrc\pulse_detector_ipcore\PulseDet_src_HDL_FIFO.v
// Created: 2023-08-26 18:01:38
// 
// Generated by MATLAB 9.13 and HDL Coder 4.0
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PulseDet_src_HDL_FIFO
// Source Path: pulse_detector_ipcore/Pulse Detector IP/To Output Stream/HDL_FIFO
// Hierarchy Level: 2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PulseDet_src_HDL_FIFO
          (clk,
           reset,
           enb,
           In_re,
           In_im,
           Push,
           Pop,
           Out_re,
           Out_im,
           Empty,
           Num);


  input   clk;
  input   reset;
  input   enb;
  input   signed [15:0] In_re;  // sfix16_En14
  input   signed [15:0] In_im;  // sfix16_En14
  input   Push;
  input   Pop;
  output  signed [15:0] Out_re;  // sfix16_En14
  output  signed [15:0] Out_im;  // sfix16_En14
  output  Empty;  // ufix1
  output  [6:0] Num;  // ufix7


  wire R_x;  // ufix1
  wire cache_wr_en;  // ufix1
  wire out_wr_en;  // ufix1
  wire fwft_wr_en;  // ufix1
  wire R_x_1;  // ufix1
  reg  fifo_valid;  // ufix1
  wire Q_keep;  // ufix1
  reg  out_valid;  // ufix1
  wire fifo_and_out_valid;  // ufix1
  wire R_x_2;  // ufix1
  reg  cache_valid;  // ufix1
  wire Q_keep_1;  // ufix1
  wire relop_relop1;
  wire Q_next;  // ufix1
  wire all_valid;  // ufix1
  wire Full;  // ufix1
  wire fifo_nfull;  // ufix1
  wire fifo_push;  // ufix1
  wire fifo_pop;  // ufix1
  reg [5:0] fifo_front_indx;  // ufix6
  reg [5:0] fifo_front_dir;  // ufix6
  reg [5:0] fifo_back_indx;  // ufix6
  reg [5:0] fifo_back_dir;  // ufix6
  reg [6:0] fifo_sample_count;  // ufix7
  wire [5:0] fifo_front_indx_next;  // ufix6
  wire [5:0] fifo_front_dir_next;  // ufix6
  wire [5:0] fifo_back_indx_next;  // ufix6
  wire [5:0] fifo_back_dir_next;  // ufix6
  wire [6:0] fifo_sample_count_next;  // ufix7
  wire fifo_out3;
  wire fifo_out4;
  wire fifo_write_enable;
  wire fifo_read_enable;
  wire [5:0] fifo_front_indx_temp;  // ufix6
  wire [5:0] fifo_back_indx_temp;  // ufix6
  wire [5:0] w_waddr;  // ufix6
  wire w_we;  // ufix1
  wire [5:0] w_raddr;  // ufix6
  wire Empty_1;  // ufix1
  wire [6:0] Num_1;  // ufix7
  wire Q_next_1;  // ufix1
  wire int_valid;  // ufix1
  wire Q_keep_2;  // ufix1
  wire Q_next_2;  // ufix1
  wire data_flow;  // ufix1
  wire w_cz;
  wire w_const;  // ufix1
  wire w_mux1;  // ufix1
  reg  w_d1;  // ufix1
  wire signed [15:0] w_waddr_re;  // sfix16_En14
  wire signed [15:0] w_waddr_im;  // sfix16_En14
  reg signed [15:0] w_d2_re;  // sfix16_En14
  reg signed [15:0] w_d2_im;  // sfix16_En14
  wire signed [15:0] w_out_re;  // sfix16_En14
  wire signed [15:0] w_out_im;  // sfix16_En14
  reg signed [15:0] cache_data_re;  // sfix16_En14
  reg signed [15:0] cache_data_im;  // sfix16_En14
  wire signed [15:0] data_out_next_re;  // sfix16_En14
  wire signed [15:0] data_out_next_im;  // sfix16_En14
  reg signed [15:0] Out_re_1;  // sfix16_En14
  reg signed [15:0] Out_im_1;  // sfix16_En14
  wire [1:0] num_int_adder_stage2_1;  // ufix2
  wire [1:0] num_int_adder_stage2_2;  // ufix2
  wire [1:0] num_int_adder_op_stage1;  // ufix2
  wire [1:0] num_int_adder_stage3_1;  // ufix2
  wire [1:0] num_int;  // ufix2
  wire [6:0] num_int_adder_1;  // ufix7


  assign R_x =  ~ Pop;



  assign fwft_wr_en = cache_wr_en | out_wr_en;



  assign R_x_1 =  ~ fwft_wr_en;



  assign Q_keep = R_x_1 & fifo_valid;



  assign fifo_and_out_valid = fifo_valid & out_valid;



  assign R_x_2 =  ~ out_wr_en;



  assign Q_keep_1 = R_x_2 & cache_valid;



  assign relop_relop1 = cache_valid == out_wr_en;



  assign cache_wr_en = relop_relop1 & fifo_valid;



  assign Q_next = cache_wr_en | Q_keep_1;



  always @(posedge clk)
    begin : Q_reg_process
      if (reset == 1'b1) begin
        cache_valid <= 1'b0;
      end
      else begin
        if (enb) begin
          cache_valid <= Q_next;
        end
      end
    end



  assign all_valid = cache_valid & fifo_and_out_valid;



  assign fifo_nfull =  ~ Full;



  // us2: Upsample by 1, Sample offset 0 
  assign fifo_push = Push & fifo_nfull;



  // FIFO logic controller
  always @(posedge clk)
    begin : fifo_process
      if (reset == 1'b1) begin
        fifo_front_indx <= 6'b000000;
        fifo_front_dir <= 6'b000001;
        fifo_back_indx <= 6'b000000;
        fifo_back_dir <= 6'b000001;
        fifo_sample_count <= 7'b0000000;
      end
      else begin
        if (enb) begin
          fifo_front_indx <= fifo_front_indx_next;
          fifo_front_dir <= fifo_front_dir_next;
          fifo_back_indx <= fifo_back_indx_next;
          fifo_back_dir <= fifo_back_dir_next;
          fifo_sample_count <= fifo_sample_count_next;
        end
      end
    end

  assign fifo_out4 = fifo_sample_count == 7'b1000000;
  assign fifo_out3 = fifo_sample_count == 7'b0000000;
  assign fifo_write_enable = fifo_push && (fifo_pop || ( ! fifo_out4));
  assign fifo_read_enable = fifo_pop && ( ! fifo_out3);
  assign fifo_front_indx_temp = (fifo_read_enable ? fifo_front_indx + fifo_front_dir :
              fifo_front_indx);
  assign fifo_front_dir_next = (fifo_front_indx_temp == 6'b111111 ? 6'b000001 :
              6'b000001);
  assign fifo_back_indx_temp = (fifo_write_enable ? fifo_back_indx + fifo_back_dir :
              fifo_back_indx);
  assign fifo_back_dir_next = (fifo_back_indx_temp == 6'b111111 ? 6'b000001 :
              6'b000001);
  assign fifo_sample_count_next = (fifo_write_enable && ( ! fifo_read_enable) ? fifo_sample_count + 7'b0000001 :
              (( ! fifo_write_enable) && fifo_read_enable ? fifo_sample_count + 7'b1111111 :
              fifo_sample_count));
  assign w_waddr = fifo_back_indx;
  assign w_we = fifo_write_enable;
  assign w_raddr = fifo_front_indx;
  assign Empty_1 = fifo_out3;
  assign Full = fifo_out4;
  assign Num_1 = fifo_sample_count;
  assign fifo_front_indx_next = fifo_front_indx_temp;
  assign fifo_back_indx_next = fifo_back_indx_temp;



  // us3: Upsample by 1, Sample offset 0 
  assign fifo_pop =  ~ (Empty_1 | all_valid);



  assign Q_next_1 = fifo_pop | Q_keep;



  always @(posedge clk)
    begin : Q_reg_1_process
      if (reset == 1'b1) begin
        fifo_valid <= 1'b0;
      end
      else begin
        if (enb) begin
          fifo_valid <= Q_next_1;
        end
      end
    end



  assign int_valid = fifo_valid | cache_valid;



  assign Q_keep_2 = R_x & out_valid;



  assign Q_next_2 = out_wr_en | Q_keep_2;



  always @(posedge clk)
    begin : Q_reg_2_process
      if (reset == 1'b1) begin
        out_valid <= 1'b0;
      end
      else begin
        if (enb) begin
          out_valid <= Q_next_2;
        end
      end
    end



  assign Empty =  ~ out_valid;



  assign data_flow = Pop | Empty;



  assign out_wr_en = data_flow & int_valid;



  assign w_cz = Num_1 > 7'b0000000;



  assign w_const = 1'b0;



  assign w_mux1 = (w_cz == 1'b0 ? w_const :
              fifo_pop);



  always @(posedge clk)
    begin : f_d1_process
      if (reset == 1'b1) begin
        w_d1 <= 1'b0;
      end
      else begin
        if (enb) begin
          w_d1 <= w_mux1;
        end
      end
    end



  // us1: Upsample by 1, Sample offset 0 
  PulseDet_src_SimpleDualPortRAM_generic #(.AddrWidth(6),
                                           .DataWidth(16)
                                           )
                                         u_HDL_FIFO_classic_ram_generic (.clk(clk),
                                                                         .enb(enb),
                                                                         .wr_din_re(In_re),
                                                                         .wr_din_im(In_im),
                                                                         .wr_addr(w_waddr),
                                                                         .wr_en(w_we),  // ufix1
                                                                         .rd_addr(w_raddr),
                                                                         .rd_dout_re(w_waddr_re),
                                                                         .rd_dout_im(w_waddr_im)
                                                                         );

  always @(posedge clk)
    begin : f_d2_process
      if (reset == 1'b1) begin
        w_d2_re <= 16'sb0000000000000000;
        w_d2_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb && w_d1) begin
          w_d2_re <= w_waddr_re;
          w_d2_im <= w_waddr_im;
        end
      end
    end



  assign w_out_re = (w_d1 == 1'b0 ? w_d2_re :
              w_waddr_re);
  assign w_out_im = (w_d1 == 1'b0 ? w_d2_im :
              w_waddr_im);



  always @(posedge clk)
    begin : cache_data_reg_process
      if (reset == 1'b1) begin
        cache_data_re <= 16'sb0000000000000000;
        cache_data_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb && cache_wr_en) begin
          cache_data_re <= w_out_re;
          cache_data_im <= w_out_im;
        end
      end
    end



  assign data_out_next_re = (cache_valid == 1'b0 ? w_out_re :
              cache_data_re);
  assign data_out_next_im = (cache_valid == 1'b0 ? w_out_im :
              cache_data_im);



  always @(posedge clk)
    begin : out_data_reg_process
      if (reset == 1'b1) begin
        Out_re_1 <= 16'sb0000000000000000;
        Out_im_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb && out_wr_en) begin
          Out_re_1 <= data_out_next_re;
          Out_im_1 <= data_out_next_im;
        end
      end
    end



  assign num_int_adder_stage2_1 = {1'b0, fifo_valid};
  assign num_int_adder_stage2_2 = {1'b0, cache_valid};
  assign num_int_adder_op_stage1 = num_int_adder_stage2_1 + num_int_adder_stage2_2;



  assign num_int_adder_stage3_1 = {1'b0, out_valid};
  assign num_int = num_int_adder_op_stage1 + num_int_adder_stage3_1;



  assign num_int_adder_1 = {5'b0, num_int};
  assign Num = num_int_adder_1 + Num_1;



  assign Out_re = Out_re_1;

  assign Out_im = Out_im_1;

endmodule  // PulseDet_src_HDL_FIFO

